
<details>
  <summary>Что такое прогрессивный рендеринг?</summary>
    Прогрессивный рендеринг — это метод, при котором веб-страница отображается поэтапно, начиная с самого важного контента, что позволяет пользователю быстрее увидеть часть страницы, пока она полностью загружается.

    Этот подход помогает улучшить восприятие производительности, уменьшив время, которое пользователь ждет, прежде чем сможет взаимодействовать с контентом. Например, браузер сначала загружает и отображает текст, а изображения или другие ресурсы загружаются позже.

    Используемые технологии включают **ленивую загрузку (lazy loading)** для изображений и контента, **асинхронную загрузку JavaScript** и **интерфейсы, которые постепенно подгружают данные**, такие как при использовании API с пагинацией или динамической подгрузкой.
  
</details>

---

<details>
  <summary>Что такое прогрессивный SSR?</summary>
    Прогрессивный SSR (Server-Side Rendering) — это метод рендеринга веб-страниц, при котором начальная верстка генерируется на сервере, а затем клиентская часть (JavaScript) постепенно загружает дополнительные данные и интерактивность.

    Основная идея заключается в том, чтобы отправить пользователю полностью сформированную страницу с сервера, что улучшает время до первого рендера, а затем динамически загружать остальную функциональность, не блокируя страницу.

    Такой подход улучшает SEO, так как поисковые роботы видят полностью рендеренную страницу, и ускоряет восприятие страницы пользователем.
  
</details>

---

<details>
  <summary>SSR (Server-Side Rendering) и CSR (Client-Side Rendering) плюсы и минусы?</summary>

**SSR (Server-Side Rendering)**

_Плюсы:_

-   **Быстрая начальная загрузка**: страница сразу отправляется в виде готового HTML, что сокращает время до первого рендера.
-   **SEO**: так как контент уже сгенерирован на сервере, поисковые системы могут легко индексировать страницу.
-   **Лучший опыт для пользователей с медленным интернетом**: меньше данных передается по сети.

_Минусы:_

-   **Больше нагрузки на сервер**: каждый запрос требует рендеринга страницы на сервере, что может привести к увеличению времени обработки.
-   **Необходимость в повторном рендеринге при каждом обновлении**: изменения на клиенте требуют дополнительных запросов к серверу.

----------

**CSR (Client-Side Rendering)**

_Плюсы:_

-   **Меньше нагрузки на сервер**: основной рендеринг происходит на клиенте, сервер только предоставляет данные.
-   **Быстрая динамическая навигация**: после начальной загрузки страница работает быстрее, так как не требует перезагрузки при переходах между страницами.

_Минусы:_

-   **Медленнее начальная загрузка**: клиент должен загрузить JavaScript, чтобы отрендерить контент, что может увеличить время до первого рендера.
-   **Проблемы с SEO**: поисковые системы могут не индексировать страницы должным образом, если они сильно зависят от JavaScript.
  
</details>

---

<details>
  <summary>Что такое Progressive Web Application (PWA)?</summary>
    Progressive Web Application (PWA) — это веб-приложение, которое сочетает функциональность веб-сайтов с опытом использования нативных мобильных приложений. PWA работают в браузере, но обладают такими возможностями, как офлайн-доступ, push-уведомления и добавление на главный экран устройства.

    **Ключевые особенности PWA**:

    -   **Кроссплатформенность**: работает на любых устройствах с браузером.
    -   **Офлайн-режим**: благодаря сервисным воркерам контент доступен даже без интернета.
    -   **Высокая производительность**: мгновенные загрузки за счет кэширования.

    PWA улучшает пользовательский опыт, делая веб-приложения быстрыми, надежными и удобными, как нативные приложения.
  
</details>

---

<details>
  <summary>Что такое OSI модель?</summary>

  OSI (Open Systems Interconnection) — это модель сетевого взаимодействия, описывающая, как данные передаются между устройствами в сети. Она разделяет процесс передачи данных на **семь уровней**, каждый из которых выполняет свою задачу.

**Семь уровней OSI**:

1.  **Физический**: отвечает за физическую передачу данных (кабели, разъемы, сигналы).
2.  **Канальный**: обеспечивает надежную передачу данных между устройствами, управляя доступом к физической среде.
3.  **Сетевой**: определяет маршрутизацию данных через сети (например, IP).
4.  **Транспортный**: обеспечивает надежность передачи (TCP, UDP).
5.  **Сеансовый**: управляет соединениями между приложениями.
6.  **Представления**: отвечает за преобразование данных (шифрование, сжатие).
7.  **Прикладной**: взаимодействует с приложениями и предоставляет интерфейсы для пользователя (HTTP, FTP).

Эта модель помогает стандартизировать сетевое взаимодействие и упростить диагностику проблем.
</details>

---

<details>
  <summary>Что такое поток документа?</summary>

Поток документа (document flow) в веб-разработке — это способ, которым браузер размещает HTML-элементы на странице, исходя из их типов и свойств стилей.

### Основные аспекты:

1.  **Блочные элементы** (`div`, `p`, `h1`) размещаются сверху вниз, занимая всю ширину контейнера.
2.  **Инлайн-элементы** (`span`, `a`) размещаются слева направо, не нарушая строки.
3.  **Позиционирование** (например, `position: absolute`) или `float` могут вырывать элементы из потока, изменяя их расположение относительно других.

Контроль потока документа важен для создания гибких и адаптивных макетов.
  
</details>

---

<details>
  <summary>Разница между адаптивным (adaptive) и отзывчивым (responsive) дизайнами?</summary>

**Адаптивный дизайн** (Adaptive Design) и **отзывчивый дизайн** (Responsive Design) — это подходы к созданию сайтов, которые подстраиваются под разные размеры экранов.

### **Адаптивный дизайн**:

-   Основан на **фиксированных точках перелома** (breakpoints), например, для мобильных, планшетов и десктопов.
-   Каждый макет жёстко задан для определённого диапазона размеров экранов.
-   Пример: изменение структуры сайта только при достижении определённых ширин (768px, 1024px и т. д.).

_Плюсы_: точный контроль над внешним видом. _Минусы_: больше работы по созданию макетов, плохо подходит для нестандартных экранов.

----------

### **Отзывчивый дизайн**:

-   Использует **гибкие сетки** (fluid grid) и медиа-запросы для плавной подстройки под любое разрешение.
-   Элементы адаптируются динамически, например, изменяя размеры пропорционально ширине экрана.
-   Пример: ширина блока определяется в процентах, а не в пикселях.

_Плюсы_: более универсальный подход, лучше поддерживает устройства с нестандартными размерами. _Минусы_: сложнее тестировать и оптимизировать для всех экранов.

**Итог**: адаптивный дизайн предлагает макеты для конкретных устройств, а отзывчивый — гибко подстраивается под любое разрешение.
  
</details>

---

<details>
  <summary>Разница между Progressive Enhancement и Graceful Degradation?</summary>

**Progressive Enhancement** и **Graceful Degradation** — это стратегии разработки веб-приложений, направленные на обеспечение доступности функционала на разных устройствах.

----------

### **Progressive Enhancement** (Прогрессивное улучшение):

-   Сначала создаётся **базовый функционал**, доступный для всех пользователей, включая тех, у кого слабые устройства или устаревшие браузеры.
-   Затем добавляются улучшения (например, интерактивность, анимации) для современных браузеров.
-   **Пример**: Создание сайта, который работает без JavaScript, но становится интерактивным с ним.

_Плюсы_: обеспечивает доступность, важный контент всегда доступен. _Минусы_: требует больше планирования, чтобы начинать с простого.

----------

### **Graceful Degradation** (Плавное ухудшение):

-   Приложение сначала разрабатывается с учетом **полной функциональности** для современных устройств.
-   Затем добавляется поддержка для старых браузеров с урезанным функционалом.
-   **Пример**: Сложный интерфейс, который на старых устройствах теряет анимацию, но остаётся функциональным.

_Плюсы_: быстрее разрабатывать сложные современные приложения. _Минусы_: сложнее адаптировать сложный функционал под старые системы.

----------

**Сравнение**:

-   **Progressive Enhancement** ориентируется на доступность с самого начала.
-   **Graceful Degradation** — на сложные современные возможности, с упрощением для старых устройств.
  
</details>

---

<details>
  <summary>Что такое Веб-компоненты и какие технологии в них используются? </summary>
**Веб-компоненты** — это набор технологий для создания многократно используемых, инкапсулированных пользовательских элементов в веб-приложениях. Они позволяют разработчикам создавать свои HTML-теги с собственным поведением и стилями.

Основные технологии:

1.  **Custom Elements** — создание собственных HTML-элементов с использованием JavaScript (например, `<my-button>`).
2.  **Shadow DOM** — инкапсуляция стилей и структуры элемента, чтобы они не конфликтовали с остальной частью страницы.
3.  **HTML Templates** — использование `<template>` и `<slot>` для задания разметки и динамического контента.

Веб-компоненты работают нативно в браузерах и позволяют создавать независимые модули, что упрощает разработку и повторное использование элементов.
  
</details>

---

<details>
  <summary>Особенности разработки мультиязычных сайтов?</summary>

Разработка мультиязычных сайтов требует учёта нескольких особенностей для правильного отображения и управления контентом:

1.  **Локализация контента**: обеспечение перевода текстов, изображений, форматов дат, чисел и валют для каждого языка. Используются файлы переводов (например, JSON, YAML) или системы управления локализацией (i18n).
    
2.  **SEO для разных языков**: настройка тегов `<html lang="...">`, использование hreflang в мета-тегах для указания региональных версий страниц. Разделение языков через поддомены, подкаталоги или домены верхнего уровня (например, `en.site.com`, `site.com/en/`).
    
3.  **UI/UX адаптация**: учёт направлений текста (LTR и RTL), длины строк, шрифтов и культурных различий. Для RTL (арабский, иврит) важна адаптация стилей, например `text-align: right`.
  
</details>

---

<details>
  <summary>Что такое REST?</summary>

**REST** (Representational State Transfer) — архитектурный стиль для взаимодействия клиент-серверных систем через HTTP, основанный на использовании ресурсов.

### Основные принципы:

1.  **Ресурсы**: каждая сущность (например, пользователь или заказ) представляется уникальным URL (`/users/1`).
2.  **HTTP-методы**: используются стандартные методы:
    -   `GET` — получение данных;
    -   `POST` — создание ресурсов;
    -   `PUT/PATCH` — обновление;
    -   `DELETE` — удаление.
3.  **Статус-коды**: сервер возвращает понятные коды (200 OK, 404 Not Found).
4.  **Без состояния**: каждый запрос содержит всю необходимую информацию, сервер не хранит состояние клиента.

REST прост в реализации, масштабируем и широко используется для разработки API.
  
</details>

---

<details>
  <summary>Что такое REST и RESTful api?</summary>

**REST** (Representational State Transfer) — это архитектурный стиль для построения веб-сервисов, который фокусируется на взаимодействии с ресурсами через стандартные HTTP-методы.

**RESTful API** — это реализация API, которая следует принципам REST:

-   Ресурсы представляются в виде URL (например, `/users/1`).
-   Используются HTTP-методы (`GET`, `POST`, `PUT`, `DELETE`).
-   Ответы содержат данные в формате JSON или XML.
-   API является статeless: сервер не сохраняет состояние клиента между запросами.

**Разница**: REST — концепция, а RESTful API — её практическое воплощение в API.
  
</details>

---

<details>
  <summary>Принципы REST-архитектуры?</summary>

REST-архитектура основывается на шести ключевых принципах:

1.  **Клиент-серверная архитектура**: разделение ответственности между клиентом (интерфейс пользователя) и сервером (управление данными и бизнес-логикой).
    
2.  **Без состояния (Stateless)**: каждый запрос от клиента содержит всю необходимую информацию, сервер не сохраняет состояние клиента между запросами.
    
3.  **Кешируемость**: ответы от сервера должны содержать информацию о том, можно ли их кешировать, чтобы уменьшить нагрузку на сервер и ускорить обработку запросов.
    
4.  **Единообразие интерфейса**: стандартизация взаимодействия между клиентом и сервером с использованием понятных URL, стандартных HTTP-методов и статусов.
    
5.  **Слои системы**: архитектура может включать промежуточные слои (например, балансировщики, кеши), которые не нарушают взаимодействие между клиентом и сервером.
    
6.  **Код по требованию (опционально)**: сервер может передавать клиенту исполняемый код (например, JavaScript), чтобы расширить его функциональность.
    

Эти принципы обеспечивают простоту, масштабируемость и гибкость REST-систем.
</details>

---

<details>
  <summary>Что такое модель зрелости Ричардсона? Что такое уровни модели?</summary>

**Модель зрелости Ричардсона** описывает уровни зрелости API в соответствии с принципами REST. Её предложил Мартин Фаулер на основе идей Леонарда Ричардсона.

### Уровни модели:

1.  **Уровень 0 — Эндпоинт-сервис**:  
    API использует один эндпоинт, обрабатывающий все запросы. Пример: RPC (Remote Procedure Call) с передачей действий через тело запроса.
    
2.  **Уровень 1 — Ресурсы**:  
    Вводится понятие ресурсов с уникальными URL. Пример:
    
    -   `/users` — коллекция пользователей;
    -   `/users/1` — конкретный пользователь.
3.  **Уровень 2 — HTTP-методы**:  
    Используются стандартные методы HTTP (`GET`, `POST`, `PUT`, `DELETE`) для работы с ресурсами, а также коды состояния (200, 404).
    
4.  **Уровень 3 — Гипермедиа (HATEOAS)**:  
    Ответы API включают ссылки для навигации между связанными ресурсами. Это делает API самодокументируемым. Пример: в ответе `/users/1` можно вернуть ссылку на `/users/1/orders`.
    

**Цель модели** — помочь API-дизайнерам улучшить соответствие принципам REST и повысить удобство взаимодействия для клиентов.
  
</details>

---

<details>
  <summary>Что такое History API в браузере?</summary>


**History API** — это программный интерфейс в браузерах, позволяющий управлять историей сеанса (списком посещённых страниц) без перезагрузки страницы. Оно используется для реализации навигации в одностраничных приложениях (SPA).

### Основные возможности:

1.  **`history.pushState()`**
    
    -   Добавляет новую запись в историю браузера.
    -   Пример: `history.pushState({page: 1}, "Title", "/page1");`.
2.  **`history.replaceState()`**
    
    -   Заменяет текущую запись в истории без создания новой.
    -   Пример: `history.replaceState({page: 1}, "Title", "/page1");`.
3.  **`popstate`**
    
    -   Событие, которое срабатывает при переходе по истории (например, при нажатии кнопок "Назад" или "Вперёд").

### Преимущества:

-   Позволяет обновлять URL без перезагрузки страницы.
-   Сохраняет пользовательский опыт: работает кнопка "Назад".
-   Удобно для построения динамических приложений.

Пример использования в SPA: обновление содержимого страницы при изменении URL, как в маршрутизации.
  
</details>

---

<details>
  <summary>Что такое веб-хранилище (web storage)?</summary>

**Веб-хранилище (Web Storage)** — это механизм HTML5 для локального сохранения данных в браузере. Оно предоставляет два типа хранилищ:

### Основные типы:

1.  **LocalStorage**
    
    -   Данные сохраняются без срока действия.
    -   Доступны даже после перезапуска браузера.
    -   Используется для хранения настроек, предпочтений и другой информации, которая нужна постоянно.
    -   Пример: `localStorage.setItem('key', 'value');`.
2.  **SessionStorage**
    
    -   Данные сохраняются только на время текущей сессии (пока вкладка открыта).
    -   Удаляются при закрытии вкладки или окна.
    -   Подходит для временных данных, таких как состояние формы.
    -   Пример: `sessionStorage.setItem('key', 'value');`.

### Преимущества:

-   Простота использования.
-   Локальное хранение до 5–10 МБ данных (в зависимости от браузера).
-   Быстрее и удобнее, чем использование cookies (не отправляются на сервер с каждым запросом).

Используется для улучшения производительности и пользовательского опыта.
  
</details>

---

<details>
  <summary>Разница между cookie, sessionStorage и localStorage?</summary>

Вот ключевые различия между **cookie**, **localStorage** и **sessionStorage**:

| Характеристика         | Cookie                          | LocalStorage                   | SessionStorage                |
|-------------------------|---------------------------------|--------------------------------|--------------------------------|
| **Объем хранения**     | До 4 КБ                        | 5–10 МБ                        | 5–10 МБ                       |
| **Срок хранения**       | Указывается вручную (expires)  | Постоянное, пока не удалено    | До закрытия вкладки           |
| **Доступ на сервере**  | Отправляются с каждым запросом | Доступно только в браузере     | Доступно только в браузере    |
| **Область видимости**  | Между вкладками и окнами       | Между вкладками и окнами       | Только текущая вкладка        |
| **Использование**       | Аутентификация, сессии         | Настройки, данные пользователя | Временные данные в сессии     |
| **Безопасность**        | Может быть уязвимо (XSS/CSRF) | Защищено от отправки на сервер | Защищено от отправки на сервер | 

### Итоги:

-   **Cookies** — подходят для серверного взаимодействия.
-   **localStorage** — для долгосрочного хранения данных.
-   **sessionStorage** — для временных данных в пределах одной вкладки.
  
</details>

---

<details>
  <summary>Что такое HTTP?</summary>
    **HTTP (Hypertext Transfer Protocol)** — это протокол, который используется для передачи данных между клиентом (например, браузером) и сервером в интернете. Он основан на запросах и ответах, что позволяет запрашивать ресурсы (веб-страницы, изображения, файлы и т. д.) с серверов и получать ответы.

### Основные особенности HTTP:

1.  **Без сохранения состояния** — каждый запрос и ответ независимы. Сервер не хранит информацию о предыдущих запросах (для этого используют сессии или cookies).
2.  **Методы HTTP** — определяют действия с ресурсами, например:
    -   `GET` — запросить ресурс.
    -   `POST` — отправить данные на сервер.
    -   `PUT` — обновить ресурс.
    -   `DELETE` — удалить ресурс.
3.  **Статус-коды** — показывают результат выполнения запроса, например, `200 OK`, `404 Not Found`, `500 Internal Server Error`.

HTTP является основой для работы веба, и используется для загрузки страниц и общения между клиентами и серверами.
</details>

---

<details>
  <summary>Из чего состоит HTTP-запрос?</summary>

**HTTP-запрос** состоит из нескольких частей:

1.  **Метод (Request Method)**  
    Указывает, какое действие требуется выполнить с ресурсом (например, `GET`, `POST`, `PUT`, `DELETE`).
    
2.  **URL (Uniform Resource Locator)**  
    Адрес ресурса, к которому осуществляется запрос (например, `/index.html`).
    
3.  **Версия протокола (HTTP Version)**  
    Указывает используемую версию HTTP (например, `HTTP/1.1`).
    
4.  **Заголовки (Headers)**  
    Дополнительная информация о запросе или о клиенте. Примеры:
    
    -   `User-Agent` — информация о браузере клиента.
    -   `Accept` — типы данных, которые клиент может обработать.
    -   `Authorization` — данные для аутентификации.
5.  **Тело запроса (Body)**  
    Используется в методах, которые отправляют данные на сервер, например, в `POST` или `PUT`. В теле запроса могут быть данные формы, JSON, файлы и другие данные.

		GET /index.html HTTP/1.1
		Host: www.example.com
		User-Agent: Mozilla/5.0
		Accept: text/html 

В этом примере используется метод `GET`, URL `/index.html`, и указаны заголовки `Host`, `User-Agent` и `Accept`.
  
</details>

---

<details>
  <summary>Какие методы может иметь HTTP-запрос?</summary>
    HTTP-запрос может иметь следующие основные методы:

1.  **GET** — Запрашивает ресурс с сервера. Это самый распространенный метод для получения данных.
    
2.  **POST** — Отправляет данные на сервер, например, данные формы или JSON. Часто используется для создания или отправки информации.
    
3.  **PUT** — Обновляет существующий ресурс на сервере, заменяя его целиком новыми данными.
    
4.  **DELETE** — Удаляет указанный ресурс с сервера.
    
5.  **HEAD** — Запрашивает только заголовки ресурса без самого контента. Используется для проверки доступности ресурса.
    
6.  **PATCH** — Частичное обновление ресурса, в отличие от `PUT`, который заменяет весь ресурс.
    
7.  **OPTIONS** — Запрашивает сервер о том, какие методы HTTP поддерживает для определенного ресурса. Используется для диагностики и разрешений CORS.
    
8.  **TRACE** — Запрашивает сервер отправить обратно весь запрос, полезен для диагностики и отслеживания маршрута запроса.
    

Эти методы позволяют взаимодействовать с ресурсами на сервере разными способами в зависимости от нужд приложения.
  
</details>

---

<details>
  <summary>Разница между HTTP и HTTPS?</summary>

**HTTP** (Hypertext Transfer Protocol) и **HTTPS** (Hypertext Transfer Protocol Secure) — это два протокола для передачи данных по сети, но с ключевыми различиями:

1.  **Шифрование**:
    
    -   **HTTP** передает данные в открытом виде, без защиты. Это делает их уязвимыми для перехвата и манипуляций (например, через атаки типа "man-in-the-middle").
    -   **HTTPS** использует **SSL/TLS** (Secure Sockets Layer/Transport Layer Security) для шифрования данных, что обеспечивает их конфиденциальность и целостность.
2.  **Безопасность**:
    
    -   **HTTP** не гарантирует безопасность данных и может быть подвержен различным атакам.
    -   **HTTPS** обеспечивает защиту от перехвата, подделки данных и атак на целостность передаваемой информации.
3.  **Порт**:
    
    -   **HTTP** использует стандартный порт 80.
    -   **HTTPS** работает через защищённый порт 443.

Использование **HTTPS** обязательно для сайтов, которые обрабатывают чувствительные данные (например, банковские реквизиты, личную информацию), так как оно обеспечивает безопасность и доверие пользователей.
  
</details>

---

<details>
  <summary>Разница между HTTP/1 и HTTP/2?</summary>
**HTTP/1** и **HTTP/2** отличаются следующим:

1.  **Многозадачность**: HTTP/1 использует одно соединение для каждого запроса, HTTP/2 поддерживает мультиплексирование — несколько запросов по одному соединению.
    
2.  **Сжатие заголовков**: HTTP/2 сжимает заголовки, уменьшая объем данных, в отличие от HTTP/1.
    
3.  **Приоритезация запросов**: HTTP/2 позволяет управлять приоритетами запросов, улучшая производительность.
    

HTTP/2 быстрее и эффективнее, чем HTTP/1, благодаря улучшенному управлению соединениями и сжатию.
  
</details>

---

<details>
  <summary>Как работает мультиплексирование в HTTP/2?</summary>

Мультиплексирование в **HTTP/2** позволяет отправлять несколько запросов и получать ответы одновременно по одному соединению. Это достигается путем разделения каждого запроса и ответа на **пакеты**, которые могут передаваться параллельно. Сервер и клиент могут обрабатывать эти пакеты независимо друг от друга, без блокировки, улучшая производительность.

Вместо того чтобы ждать завершения одного запроса перед отправкой следующего, как в HTTP/1, в HTTP/2 все запросы отправляются одновременно, а ответы собираются и возвращаются в том порядке, в котором они были обработаны. Это снижает задержки и повышает эффективность использования сетевых ресурсов.
  
</details>

---

<details>
  <summary>Что такое “трехстороннее рукопожатие” (Triple handshake)?</summary>
**Трехстороннее рукопожатие** (Triple handshake) — это процесс установления безопасного соединения в протоколе **TLS/SSL**, который используется в **HTTPS**. Он включает три основных шага:

1.  **Client Hello**: Клиент отправляет серверу запрос на установление соединения, включая информацию о поддерживаемых криптографических методах.
2.  **Server Hello**: Сервер отвечает, выбирая наиболее подходящий метод и отправляя свой сертификат для аутентификации.
3.  **Finished**: Клиент и сервер обмениваются подтверждениями, что они установили защищённое соединение.

Этот процесс обеспечивает **шифрование**, **проверку подлинности** и **целостность** данных между клиентом и сервером.
  
</details>

---

<details>
  <summary>Разница между PUT- и POST-запросами?</summary>

**PUT** и **POST** — это два метода HTTP, используемые для отправки данных на сервер, но с различиями в их назначении и поведении:

1.  **PUT**:
    
    -   Обновляет или заменяет ресурс по указанному URL.
    -   Запрос идемпотентен, то есть несколько одинаковых запросов не изменят результат.
    -   Ожидает, что клиент отправит полный набор данных для замены ресурса.
2.  **POST**:
    
    -   Используется для создания нового ресурса или выполнения действия, требующего обработки сервером.
    -   Не идемпотентен — повторный POST-запрос может создать несколько копий ресурса.
    -   Может отправлять частичные данные или инициировать операции (например, форму).

**PUT** фокусируется на обновлении, а **POST** — на создании или инициировании действий.
  
</details>

---

<details>
  <summary>Разница между протоколами TCP и UDP?</summary>

**TCP** (Transmission Control Protocol) и **UDP** (User Datagram Protocol) — это два транспортных протокола, используемых для передачи данных в сети, но с различными характеристиками:

1.  **TCP**:
    
    -   **Соединориентированный**: Устанавливает соединение перед передачей данных.
    -   **Надежность**: Гарантирует доставку пакетов, с контролем ошибок, подтверждениями и повторной передачей потерянных данных.
    -   **Медленнее**: Из-за дополнительной обработки (например, управление потоком и ошибка) более медленный, чем UDP.
2.  **UDP**:
    
    -   **Без соединения**: Отправка данных без установления соединения.
    -   **Ненадежность**: Не гарантирует доставку данных, отсутствие подтверждений и повторной передачи потерянных пакетов.
    -   **Быстрее**: За счет минимальной обработки, более быстрый, но менее надежный.

**TCP** используется, где важна надежность (например, в веб-приложениях), а **UDP** — для быстрого обмена данными, где потери пакетов допустимы (например, в стриминге или онлайн-играх).
  
</details>

---

<details>
  <summary>Что такое WebSocket? В чем принцип его работы?</summary>
  
**WebSocket** — это протокол связи, который обеспечивает двустороннюю связь между клиентом и сервером через одно TCP-соединение. Он позволяет обмениваться данными в реальном времени без необходимости повторно устанавливать соединение, как это происходит в HTTP.

Принцип работы:

1.  **Установление соединения**: Клиент инициирует соединение с сервером через HTTP-запрос, который затем апгрейдится в WebSocket-соединение (с помощью заголовка `Upgrade`).
2.  **Двусторонняя связь**: После установления соединения, клиент и сервер могут отправлять данные в обоих направлениях без необходимости повторных запросов.
3.  **Поддержка в реальном времени**: Соединение остается открытым, позволяя обмениваться данными в реальном времени, что идеально подходит для чатов, игр или финансовых приложений.

**WebSocket** эффективен для приложений, требующих быстрой и постоянной передачи данных без накладных расходов, связанных с установкой новых соединений.
</details>

---

<details>
  <summary>Разница между Long-Polling, Websockets и Server-Sent Events?</summary>

**Long-Polling**, **WebSockets** и **Server-Sent Events (SSE)** — методы для связи в реальном времени, с разными подходами:

1.  **Long-Polling**:
    
    -   Клиент отправляет запрос, сервер удерживает его до появления новых данных.
    -   **Недостатки**: Задержки и нагрузка, так как каждый запрос требует нового соединения.
    -   **Используется**: Когда другие методы невозможны.
2.  **WebSockets**:
    
    -   Двусторонняя связь по открытому соединению.
    -   **Преимущества**: Низкие задержки, эффективная двусторонняя связь.
    -   **Используется**: Для чатов, игр, обмена данными.
3.  **Server-Sent Events (SSE)**:
    
    -   Однонаправленная связь от сервера к клиенту.
    -   **Преимущества**: Легче в реализации, использует HTTP.
    -   **Используется**: Для новостных лент и обновлений.

**Итого**: Long-Polling — наименее эффективен, SSE — однонаправленный поток, WebSockets — для двусторонней связи с низкими задержками.
</details>

---

<details>
  <summary>Как работает JSONP?</summary>

**JSONP (JSON with Padding)** — это техника для обхода политики одинакового происхождения (Same-Origin Policy) в браузерах, позволяющая выполнять запросы к серверам, расположенным на других доменах.

Принцип работы:

1.  **Запрос**: Вместо обычного XMLHttpRequest, клиент создает `<script>` тег с указанием URL-адреса сервера и параметров запроса.
2.  **Ответ**: Сервер возвращает JavaScript-функцию (например, `callback()`) с данными в качестве аргумента.
3.  **Обработка**: Браузер выполняет полученный скрипт, и данные передаются в указанную функцию.

**Преимущества**: Позволяет делать запросы к сторонним ресурсам без блокировки CORS.

**Недостатки**: Работает только с GET-запросами и может быть уязвимым для XSS атак.
  
</details>

---

<details>
  <summary>Что такое IndexedDB в браузере? Преимущества IndexedDB?</summary>

**IndexedDB** — это низкоуровневая система хранения данных в браузере, позволяющая сохранять значительные объемы данных в виде объектов и выполнять асинхронные операции для их поиска и модификации.

**Преимущества**:

1.  **Местное хранение данных**: Позволяет хранить большие объемы данных (в отличие от cookies или localStorage).
2.  **Асинхронность**: Операции выполняются асинхронно, не блокируя основной поток.
3.  **Поддержка индексов**: Дает возможность эффективно искать данные с использованием индексов.
4.  **Структура данных**: Поддерживает хранение сложных объектов и различных типов данных (не только строки).
5.  **Постоянство**: Данные сохраняются даже при перезагрузке страницы или закрытии браузера.

IndexedDB часто используется для реализации офлайн-режимов и кэширования данных в веб-приложениях.
  
</details>

---

<details>
  <summary>Что такое Service Workers?</summary>

**Service Workers** — это скрипты, которые работают в фоновом режиме и позволяют веб-приложениям работать офлайн, кэшировать ресурсы и улучшать производительность, не требуя постоянного подключения к серверу.

**Основные функции**:

1.  **Оффлайн-работа**: Обработка запросов даже при отсутствии интернет-соединения.
2.  **Кэширование**: Сохранение файлов в кэше для более быстрого доступа.
3.  **Фоновые задачи**: Обработка уведомлений, синхронизация данных и другие фоновые операции.
4.  **Перехват запросов**: Могут перехватывать и изменять HTTP-запросы, обеспечивая гибкость в обработке данных.

**Используется** в PWA (Progressive Web Apps) для улучшения пользовательского опыта, обеспечения работы без интернета и улучшения производительности.
  
</details>

---
<details>
  <summary>Что такое Web Workers?</summary>

**Web Workers** — это API, позволяющее запускать JavaScript код в отдельных потоках (параллельно основному потоку), что позволяет улучшить производительность веб-приложений, особенно для тяжелых или долгих вычислений.

**Основные характеристики**:

1.  **Параллельное выполнение**: Работают в фоновом потоке, не блокируя основной поток, что улучшает отзывчивость интерфейса.
2.  **Асинхронность**: Работают асинхронно, передавая данные между основным потоком и рабочим потоком через события и сообщения.
3.  **Изоляция**: Каждый worker имеет собственную среду выполнения и не может напрямую взаимодействовать с DOM, но может обмениваться сообщениями с основным потоком.

**Используется** для выполнения ресурсоемких задач, таких как обработка данных или вычисления, чтобы не замедлять работу интерфейса.
  
</details>

---

<details>
  <summary>Что такое Web Worklet?</summary>

**Web Worklet** — это более легковесная версия Web Worker, предназначенная для выполнения небольших фрагментов кода в отдельном потоке, обычно для задач, требующих минимальной задержки, таких как обработка графики или аудио в реальном времени.

**Основные особенности**:

1.  **Малый размер**: Web Worklets создаются для выполнения специфических задач с минимальными ресурсами.
2.  **Быстрая интеграция**: Используются для обработки визуальных или аудиофрагментов (например, с API CSS или Audio Worklet).
3.  **Отсутствие доступа к DOM**: Как и Web Workers, Web Worklets не могут напрямую взаимодействовать с DOM, но они обеспечивают быстрые вычисления и улучшенную производительность.

**Применение**: Веб-компоненты, работающие с графикой (например, в CSS) или аудио, где важна высокая производительность и низкая задержка.
  
</details>

---

<details>
  <summary>Механизм установки сеанса между клиентом и сервером?</summary>
Механизм установки сеанса между клиентом и сервером?

**Механизм установки сеанса** между клиентом и сервером обычно включает в себя использование **cookies** или **сессионных токенов** для отслеживания и поддержания состояния между запросами.

1.  **Инициализация сеанса**: Когда клиент впервые подключается к серверу, сервер генерирует уникальный идентификатор сеанса (например, сессионный ID) и отправляет его клиенту через cookie или в теле ответа.
    
2.  **Передача идентификатора**: В последующих запросах клиент отправляет этот идентификатор вместе с запросом (чаще всего через cookie или в заголовке HTTP), чтобы сервер мог идентифицировать пользователя и восстановить его состояние.
    
3.  **Поддержание состояния**: Сервер использует идентификатор сеанса для связывания запросов с сохраненной на сервере информацией о пользователе (например, авторизационные данные или предпочтения), позволяя пользователю оставаться "в системе" без повторной аутентификации.
    
4.  **Завершение сеанса**: Когда пользователь выходит из системы или сеанс истекает, сервер удаляет сессионные данные, и клиент перестает отправлять идентификатор сессии в запросах.
  
</details>

---

<details>
  <summary>Что Такое API?</summary>
**API (Application Programming Interface)** — это набор инструментов, протоколов и стандартов, которые позволяют различным программам взаимодействовать друг с другом. API определяет, как запросы и данные должны передаваться между системами, обеспечивая интерфейс для взаимодействия.

**Основные типы API**:

1.  **Web API**: Позволяет взаимодействовать с веб-приложениями через интернет, например, RESTful API или GraphQL.
2.  **Библиотечные API**: Предоставляют функциональность для использования в других приложениях или библиотеках.
3.  **Операционные системы API**: Интеграция с функциями ОС, такими как файловая система, сетевые соединения.

**Использование**: API широко используется для взаимодействия между клиентом и сервером, обмена данными между приложениями и расширения функциональности без необходимости доступа к внутренним деталям другой программы.
  
</details>

---

<details>
  <summary>Что такое CDN?</summary>

**CDN (Content Delivery Network)** — это сеть распределенных серверов, предназначенная для доставки контента (например, текстов, изображений, видео) пользователям с минимальной задержкой и высокой производительностью. Серверы CDN находятся в разных географических точках, что позволяет доставлять данные с ближайшего к пользователю сервера.

**Преимущества CDN**:

1.  **Ускорение загрузки**: Минимизация времени отклика за счет выбора ближайшего к пользователю сервера.
2.  **Нагрузочное распределение**: Снижение нагрузки на основной сервер, поскольку контент кэшируется на нескольких серверах.
3.  **Повышенная надежность**: В случае сбоя одного из серверов данные могут быть получены с другого, обеспечивая стабильную работу сайта.

**Применение**: Используется для ускорения загрузки веб-сайтов, стриминга видео, распространения больших файлов и улучшения безопасности за счет защиты от DDoS-атак.
  
</details>

---
<details>
  <summary>Что такое IP-адрес?</summary>
    **IP-адрес (Internet Protocol address)** — это уникальный идентификатор, который присваивается каждому устройству в сети, чтобы оно могло отправлять и получать данные через интернет или локальную сеть. IP-адрес состоит из чисел и разделен точками (IPv4) или двоичных блоков (IPv6).

**Типы IP-адресов**:

1.  **IPv4**: 32-битный адрес, записывается как четыре десятичные группы, разделенные точками (например, 192.168.0.1).
2.  **IPv6**: 128-битный адрес, используется для решения проблемы исчерпания адресов в IPv4, записывается шестнадцатеричными числами, разделенными двоеточиями (например, 2001:0db8:85a3:0000:0000:8a2e:0370:7334).

**Назначение**: IP-адрес позволяет устройствам находить друг друга в сети и обмениваться данными. IP-адреса могут быть **статическими** (постоянными) или **динамическими** (меняющимися).
  
</details>

---

<details>
  <summary>Разница между host и domain?</summary>

**Host** и **domain** — это два термина, связанные с адресацией в интернете, но их значения отличаются:

1.  **Domain (домен)** — это уникальное имя, которое используется для идентификации ресурса в интернете. Например, в адресе `www.example.com`, доменом является `example.com`. Доменное имя часто используется для упрощения доступа к веб-ресурсам, заменяя числовые IP-адреса.
    
2.  **Host (хост)** — это устройство или сервер, подключенный к сети и предоставляющий ресурсы, такие как веб-сайт или файлы. Хост может быть частью домена. Например, `www` в `www.example.com` — это поддомен или хост, указывающий на конкретный сервер или службу в домене `example.com`.
    

**Пример**: В `www.example.com`:

-   **example.com** — домен.
-   **www** — хост, указывающий на конкретный сервер для веб-сайта.
  
</details>

---

<details>
  <summary>Разница между URI и URL?</summary>

**URI (Uniform Resource Identifier)** и **URL (Uniform Resource Locator)** — оба термина относятся к адресации ресурсов в интернете, но их значения различаются:

1.  **URI** — это более общее понятие, которое используется для идентификации ресурса. URI может быть как **URL**, так и **URN** (Uniform Resource Name). Он не обязательно указывает, как получить ресурс, а лишь его уникальное имя. Пример URI: `example://path/to/resource`.
    
2.  **URL** — это подмножество URI, которое указывает на местоположение ресурса и методы его доступа. URL включает информацию о схеме (например, HTTP, FTP), домене, порте и пути. Пример URL: `https://www.example.com/index.html`.
    

**Разница**: Все URL — это URI, но не все URI являются URL. URI может не содержать данных о местоположении ресурса, в отличие от URL, который всегда указывает путь к ресурсу.
  
</details>

---

<details>
  <summary>Почему очищать кэш важно? Как это можно сделать?</summary>

**Очищение кэша важно** для обеспечения актуальности данных, улучшения производительности и предотвращения ошибок. Когда кэшированная информация устарела, браузер или приложение может загружать старые версии файлов, что приводит к отображению неправильного контента или проблемам с функциональностью. Очищение кэша помогает обновить ресурсы и избежать конфликтов.

**Как очистить кэш**:

1.  **В браузере**:
    
    -   В большинстве браузеров: откройте настройки → история → очистить данные о просмотрах, выберите кэшированные изображения и файлы.
    -   Используйте сочетания клавиш, например, `Ctrl+Shift+Delete` в Chrome.
2.  **Программно**:
    
    -   Для серверов можно настроить заголовки кэширования или использовать сервисы для управления кэшированием, например, через `Cache-Control` или HTTP-заголовки.
    -   В некоторых приложениях можно реализовать автоматическую очистку кэша через код.

**Преимущества**: Это помогает избежать ошибок с устаревшими данными, улучшает производительность и устраняет баги.
  
</details>

---

<details>
  <summary>Что происходит когда я пишу адрес в браузерной строке?</summary>

Когда вы вводите адрес в браузерной строке, происходит несколько этапов:

1.  **Разрешение домена (DNS)**: Браузер отправляет запрос на сервер DNS, чтобы найти IP-адрес, соответствующий домену (например, `www.example.com`), так как браузеры используют IP-адреса для связи с сервером.
    
2.  **Установление соединения**: Браузер устанавливает TCP-соединение с сервером по найденному IP-адресу. Если используется HTTPS, начинается процесс SSL/TLS handshake для безопасного соединения.
    
3.  **Отправка HTTP-запроса**: После установления соединения браузер отправляет HTTP-запрос (GET или POST) к серверу для получения запрашиваемой страницы или ресурса.
    
4.  **Обработка сервером**: Сервер обрабатывает запрос, выполняет необходимые операции (например, обработка PHP-кода или доступ к базе данных) и формирует ответ в виде HTML-страницы или других данных.
    
5.  **Получение и рендеринг страницы**: Браузер получает данные и начинает рендерить страницу, выполняя дополнительные запросы для загрузки стилей, скриптов и медиа-ресурсов.
    
6.  **Кэширование**: Если это первый запрос или настройки кэширования позволяют, браузер может сохранить ресурсы локально для быстрого доступа в будущем.
    

Это процесс, который позволяет браузеру интерпретировать и показывать вам веб-страницу.
  
</details>

---